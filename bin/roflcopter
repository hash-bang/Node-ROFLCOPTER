#!/usr/bin/env node
/**
* ROFLCopter Drone control
* @author Matt Carter <m@ttcarter.com>
* @url https://github.com/hash-bang/Node-ROFLCOPTER
*/

var program = require('commander');
var arDrone = require('ar-drone');
var colors = require('colors');

console.log('ROFTCOPTER boot'.bold.blue);

program
	.version(require('../package').version)
	.option('-i, --ip [address]', 'IP address or hostname to connect to (default: "192.168.1.1")', '192.168.1.1')
	.option('--fr, --framerate [rate]', 'The framerate to stream images (default: 5)', 5)
	.option('-d, --datafeed', 'Return live data')
	.parse(process.argv);

console.log('Attaching joystick...'.blue);
try {
	var joystick = new (require('joystick'))(0, 3500, 350);
} catch(e) {
	console.log('ERROR!'.bold.red, 'Cannot find usable joystick');
	return;
}

console.log('Connecting to drone [' + program.ip + ']...');
var client  = arDrone.createClient({
	ip: program.ip,
	frameRate: program.frameRate
});

var listen = 0; // Whether to listen to commands (auto enabled after listenWait)
var listenWait = 100;
var heightSpeed = 0.4;
var buttonSpeedX = 0.8; // Speed to increase / decrease something on button repeats
var buttonRepeatX = 100; // How often to retrigger button events
var buttonSpeedY = 0.5; // Speed to increase / decrease something on button repeats
var buttonRepeatY = 100;
var maxInt = 32768;
var deadZone = 1000;

// Various timers
var dPadXFunc, dPadXTimer, dPadYFunc, dPadYTimer;

var minMax = function(value, min, max) {
	if (value < min) {
		value = min;
	} else if (value > max) {
		value = max;
	}
	return value;
}

if (program.datafeed) {
	console.log('Enabling data feed'.bold.green);
	client.config({key: 'general:navdata_demo', value: 'FALSE', timeout: 1000}, function() {
		console.log('Drone ack for data feed'.green);
	});

	client
		.on('hovering', function(data) {
			console.log('onHovering'.underline.green, data);
		})
		.on('flying', function(data) {
			console.log('onFlying'.underline.green, data);
		})
		.on('landing', function(data) {
			console.log('onLanding'.underline.green, data);
		})
		.on('batteryChange', function(data) {
			console.log('onBatteryChange'.underline.green, data);
		})
		.on('altitudeChange', function(data) {
			console.log('onAltitudeChange'.underline.green, data);
		})
		.on('navdata', function(data) {
			console.log('navData'.underline.green, data);
		});
}

joystick
	.on('button', function(data) {
		if (!listen)
			return;
		switch(data.number) {
			// D-Pad {{{
			case 0: // D-Pad Up
				if (data.value) {
					clearTimeout(dPadYTimer);
					dPadYFunc = function() {
						if (!dPadYFunc)
							return;
						client.front(buttonSpeedY);
						setTimeout(dPadYFunc, buttonRepeatY);
					};
					dPadYTimer = setTimeout(dPadYFunc, buttonRepeatY);
					console.log('Status'.green, 'Begin move forward');
				} else {
					console.log('Status'.green, 'Stop move forward');
					dPadYFunc = null;
					clearTimeout(dPadYTimer);
					client.stop();
				}
				break;
			case 1: // D-Pad Down
				if (data.value) {
					clearTimeout(dPadYTimer);
					dPadYFunc = function() {
						if (!dPadYFunc)
							return;
						client.back(buttonSpeedY);
						setTimeout(dPadYFunc, buttonRepeatY);
					};
					dPadYTimer = setTimeout(dPadYFunc, buttonRepeatY);
					console.log('Status'.green, 'Begin move backwards');
				} else {
					console.log('Status'.green, 'Stop move backwards');
					dPadYFunc = null;
					clearTimeout(dPadYTimer);
					client.stop();
				}
				break;
			case 2: // D-Pad Left
				if (data.value) {
					clearTimeout(dPadXTimer);
					dPadXFunc = function() {
						if (!dPadXFunc)
							return;
						client.counterClockwise(buttonSpeedX);
						setTimeout(dPadXFunc, buttonRepeatX);
					};
					dPadXTimer = setTimeout(dPadXFunc, buttonRepeatX);
					console.log('Status'.green, 'Begin rotate Counter-clockwise');
				} else {
					console.log('Status'.green, 'Stop rotate Counter-clockwise');
					dPadXFunc = null;
					clearTimeout(dPadXTimer);
					client.stop();
				}
				break;
			case 3: // D-Pad Right
				if (data.value) {
					clearTimeout(dPadXTimer);
					dPadXFunc = function() {
						if (!dPadXFunc)
							return;
						client.clockwise(buttonSpeedX);
						setTimeout(dPadXFunc, buttonRepeatX);
					};
					dPadXTimer = setTimeout(dPadXFunc, buttonRepeatX);
					console.log('Status'.green, 'Begin rotate Clockwise');
				} else {
					console.log('Status'.green, 'Stop rotate Clockwise');
					dPadXFunc = null;
					clearTimeout(dPadXTimer);
					client.stop();
				}
				break;
			// }}}
			case 12: // Select
				if (data.value) {
					console.log('Status'.bold.green, 'Emergency Disabled');
					client.disableEmergency();
				}
				break;
			case 13: // Start button
				if (data.value) {
					client.disableEmergency();
					console.log('Status'.bold.green, 'Take off!');
					client.takeoff(function() {
						console.log('Status'.bold.green, 'Take off confirm');
					});
				}
				break;
			case 14: // Xbox logo
				if (data.value) {
					console.log('Status'.bold.green, 'Land');
					client.land();
				}
				break;
			case 11: // Right back shoulder
				if (data.value) {
					console.log('Altitude'.magenta, '+' + heightSpeed);
					client.up(heightSpeed);
				} else {
					client.stop();
				}
				break;
			case 10: // Left back shoulder
				if (data.value) {
					console.log('Altitude'.magenta, '-' + heightSpeed);
					client.down(heightSpeed);
				} else {
					client.stop();
				}
				break;
			case 7: // Y
				if (data.value) {
					console.log('Animate'.bold.yellow, 'flipAhead');
					client.animate('flipAhead', 250);
				}
				break;
			case 4: // A
				if (data.value) {
					console.log('Animate'.bold.yellow, 'vzDance');
					client.animate('vzDance', 250);
				}
				break;
			case 6: // X
				if (data.value) {
					console.log('Animate'.bold.yellow, 'flipLeft');
					client.animate('flipLeft', 250);
				}
				break;
			case 5: // B
				if (data.value) {
					console.log('Animate'.bold.yellow, 'flipRight');
					client.animate('flipRight', 250);
				}
				break;
			case 15: // Joystick Left
			case 16: // Joystick Right
				console.log('Status'.bold.red, 'Stop');
				if (data.value) {
					client.stop();
				}
		}
	})
	.on('axis', function(data) {
		var value;
		switch(data.number) {
			case 1: // Left up/down
			case 3: // Right up/down
				if (data.value > 0-deadZone && data.value < deadZone) {
					client.stop();	
				} else if (data.value < 0) {
					client.front(minMax(1 - ((0-data.value) / maxInt)), 0, maxInt);
				} else {
					client.back(minMax(data.value / maxInt, 0, maxInt));
				}
				break;
			case 0: // Left left/right
				if (data.value > 0-deadZone && data.value < deadZone) {
					client.stop();	
				} else if (data.value < 0) {
					client.counterClockwise(minMax(1 - ((0-data.value) / maxInt)), 0, maxInt);
				} else {
					client.clockwise(minMax(data.value / maxInt, 0, maxInt));
				}
				break;
			case 2: // Right left/right
				if (data.value > 0-deadZone && data.value < deadZone) {
					client.stop();	
				} else if (data.value < 0) {
					client.left(minMax(1 - ((0-data.value) / maxInt)), 0, maxInt);
				} else {
					client.right(minMax(data.value / maxInt, 0, maxInt));
				}
				break;
		}
	});

setTimeout(function() {
	listen = true;
	console.log('Waiting for commands'.blue);
}, listenWait);
