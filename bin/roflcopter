#!/usr/bin/env node
/**
* ROFLCopter Drone control
* @author Matt Carter <m@ttcarter.com>
* @url https://github.com/hash-bang/Node-ROFLCOPTER
*/

var program = require('commander');
var arDrone = require('ar-drone');
var colors = require('colors');

console.log('ROFTCOPTER boot'.bold.blue);

program
	.version(require('../package').version)
	.option('-i, --ip [address]', 'IP address or hostname to connect to (default: "192.168.1.1")', '192.168.1.1')
	.option('--fr, --framerate [rate]', 'The framerate to stream images (default: 5)', 5)
	.option('-d, --datafeed', 'Return live data')
	.parse(process.argv);

console.log('Attaching joystick...'.blue);
var joystick = new (require('joystick'))(0, 3500, 350);
if (!joystick.id) {
	console.log('ERROR!'.bold.red, 'Cannot find usable joystick');
	return;
}

console.log('Connecting to drone [' + program.ip + ']...');
var client  = arDrone.createClient({
	ip: program.ip,
	frameRate: program.frameRate
});

if (program.datafeed)
	client.config('general:navdata_demo', 'FALSE');

var heightSpeed = 0.4;
var maxInt = 32768;
var deadZone = 1000;

var minMax = function(value, min, max) {
	if (value < min) {
		value = min;
	} else if (value > max) {
		value = max;
	}
	return value;
}

client
	.on('hovering', function(data) {
		console.log('onHovering'.underline.green, data);
	})
	.on('flying', function(data) {
		console.log('onFlying'.underline.green, data);
	})
	.on('landing', function(data) {
		console.log('onLanding'.underline.green, data);
	})
	.on('batteryChange', function(data) {
		console.log('onBatteryChange'.underline.green, data);
	})
	.on('altitudeChange', function(data) {
		console.log('onAltitudeChange'.underline.green, data);
	});

joystick
	.on('button', function(data) {
		console.log(data);
		switch(data.number) {
			case 12: // Select
				if (data.value) {
					console.log('Status'.bold.green, 'Emergency Disabled');
					client.disableEmergency();
				}
				break;
			case 13: // Start button
				if (data.value) {
					client.disableEmergency();
					console.log('Status'.bold.green, 'Take off!');
					client.takeoff(function() {
						console.log('Status'.bold.green, 'Take off confirm');
					});
				}
			case 14: // Xbox logo
				if (data.value) {
					console.log('Status'.bold.green, 'Land');
					client.land();
				}
				break;
			case 11: // Right back shoulder
				if (data.value) {
					console.log('Altitude'.magenta, '+' + heightSpeed);
					client.up(heightSpeed);
				} else {
					client.stop();
				}
				break;
			case 10: // Left back shoulder
				if (data.value) {
					console.log('Altitude'.magenta, '-' + heightSpeed);
					client.down(heightSpeed);
				} else {
					client.stop();
				}
				break;
			case 7: // Y
				if (data.value) {
					console.log('Animate'.bold.yellow, 'flipAhead');
					client.animate('flipAhead', 250);
				}
				break;
			case 4: // A
				if (data.value) {
					console.log('Animate'.bold.yellow, 'vzDance');
					client.animate('vzDance', 250);
				}
				break;
			case 6: // X
				if (data.value) {
					console.log('Animate'.bold.yellow, 'flipLeft');
					client.animate('flipLeft', 250);
				}
				break;
			case 5: // B
				if (data.value) {
					console.log('Animate'.bold.yellow, 'flipRight');
					client.animate('flipRight', 250);
				}
				break;
			case 15: // Joystick Left
			case 16: // Joystick Right
				console.log('Status'.bold.red, 'Stop');
				if (data.value) {
					client.stop();
				}
		}
	})
	.on('axis', function(data) {
		var value;
		switch(data.number) {
			case 1: // Left up/down
			case 3: // Right up/down
				if (data.value > 0-deadZone && data.value < deadZone) {
					client.stop();	
				} else if (data.value < 0) {
					client.front(minMax(1 - ((0-data.value) / maxInt)), 0, maxInt);
				} else {
					client.back(minMax(data.value / maxInt, 0, maxInt));
				}
				break;
			case 0: // Left left/right
				if (data.value > 0-deadZone && data.value < deadZone) {
					client.stop();	
				} else if (data.value < 0) {
					client.counterClockwise(minMax(1 - ((0-data.value) / maxInt)), 0, maxInt);
				} else {
					client.clockwise(minMax(data.value / maxInt, 0, maxInt));
				}
				break;
			case 2: // Right left/right
				if (data.value > 0-deadZone && data.value < deadZone) {
					client.stop();	
				} else if (data.value < 0) {
					client.left(minMax(1 - ((0-data.value) / maxInt)), 0, maxInt);
				} else {
					client.right(minMax(data.value / maxInt, 0, maxInt));
				}
				break;
		}
	});
